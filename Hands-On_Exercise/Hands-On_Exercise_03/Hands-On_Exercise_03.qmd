---
title: "Hands-On Exercise 3: 1st and 2nd Order Spatial Point Patterns Analysis Methods"
author: "Yung Qi Yang"

format: 
  html:
    code-fold: true
    code-summary: "Reveal Code"
    
execute: 
  eval: true
  echo: true
  warning: false
date: "`r Sys.Date()`"

toc: true
toc-location: left
---

## Loading the required libraries

```{r}

pacman::p_load(maptools, sf, raster, spatstat, tmap, readr)

```

## Importing the data

```{r}

mpsz_sf <- st_read(dsn = "Data/Master Plan 2014", layer = "MP14_SUBZONE_WEB_PL")
mpsz_sf

childcare_sf <- st_read(dsn = "Data/Childcare/ChildCareServices.geojson") %>%
  st_transform(crs = 3414)
childcare_sf

```

## Deriving the coastal outline data

```{r}
#|eval: false
#|echo: true

coastal_sf <- st_union(mpsz_sf)
plot(coastal_sf)

write_rds(coastal_sf, "Data/rds/coastal-outline-2014.rds")

```

## Importing the coastal outline file

```{r}

coastal_sf <- read_rds("Data/rds/coastal-outline-2014.rds")

```

## Setting the coordinate reference system of the map layers

```{r}

mpsz_sf <- mpsz_sf %>%
  st_transform(crs = 3414)

coastal_sf <- coastal_sf %>% 
  st_transform(crs = 3414)

```

## Plotting the locations of pre-schools

```{r}

tm_shape(mpsz_sf) + 
  tm_polygons() + 
  tm_shape(childcare_sf) +
  tm_dots()

```

## Using the "View" visualisation method

```{r}

tmap_mode('view')

tm_shape(childcare_sf) +
  tm_dots()

tmap_mode('plot')

```

## Converting the simple features layers to sp's "Spatial" class

```{r}

mpsz_spatial <- as_Spatial(mpsz_sf)
mpsz_spatial

coastal_spatial <- as_Spatial(coastal_sf)
coastal_spatial

childcare_spatial <- as_Spatial(childcare_sf)
childcare_spatial

```

## Converting the "Spatial" class objects into generic sp class objects

```{r}

childcare_sp <- as(childcare_spatial, "SpatialPoints")
childcare_sp

coastal_sp <- as(coastal_spatial, "SpatialPolygons")
coastal_sp

```

## Converting the generic sp class objects to spatstatâ€™s "ppp" class

```{r}

childcare_ppp <- as(childcare_sp, "ppp")
childcare_ppp

plot(childcare_ppp)
summary(childcare_ppp)

```

## Checking for duplicated points

```{r}

any(duplicated(childcare_ppp))

multiplicity(childcare_ppp)

sum(multiplicity(childcare_ppp) > 1)

tmap_mode('view')

as(as(childcare_ppp, "SpatialPoints"), "sf") %>% 
  st_set_crs(3414) %>% 
  tm_shape() +
  tm_dots(alpha=0.4, size=0.05)

```

## Handling the duplications with the jitter method

```{r}

childcare_ppp_jit <- 
  rjitter(childcare_ppp, retry = TRUE, nsim = 1, drop = TRUE)

any(duplicated(childcare_ppp_jit))

```

## Creating an *owin* object

```{r}

coastal_owin <- as(coastal_sp, "owin")

plot(coastal_owin)
summary(coastal_owin)

```

## Extracting the childcare events that occurred within Singapore

```{r}

childcareSG_ppp = childcare_ppp[coastal_owin]
summary(childcareSG_ppp)

plot(childcareSG_ppp)

```

## Conducting First-order Spatial Point Patterns Analysis

### Computing kernel density estimation using automatic bandwidth selection method

```{r}

kde_childcareSG_bw <- 
  density(childcareSG_ppp, sigma=bw.diggle, edge=TRUE, kernel="gaussian") 
plot(kde_childcareSG_bw)

```

### Obtaining bandwidth used in kernel density estimation

```{r}

bw <- bw.diggle(childcareSG_ppp)
bw

```

### Re-scaling the kernel density estimation

```{r}

childcareSG_ppp.km <- rescale(childcareSG_ppp, 1000, "km")
kde_childcareSG.bw <- 
  density(childcareSG_ppp.km, sigma = bw.diggle, edge = TRUE, kernel = "gaussian")

plot(kde_childcareSG.bw)

```

### Using different automatic bandwidth methods

#### Deriving the bandwidth of different methods

```{r}

bw.CvL(childcareSG_ppp.km)
bw.scott(childcareSG_ppp.km)
bw.ppl(childcareSG_ppp.km)
bw.diggle(childcareSG_ppp.km)

```

#### Comparing the ppl and diggle methods

```{r}

kde_childcareSG.ppl <- 
  density(childcareSG_ppp.km, sigma = bw.ppl, edge = TRUE, kernel = "gaussian")

par(mfrow = c(1,2))

plot(kde_childcareSG.bw, main = "bw.diggle")
plot(kde_childcareSG.ppl, main = "bw.ppl")

```

### Using different kernel methods

```{r}

par(mfrow = c(2,2))

plot(density(childcareSG_ppp.km, sigma = bw.ppl, edge = TRUE, kernel = "gaussian"), main="Gaussian")

plot(density(childcareSG_ppp.km, sigma = bw.ppl, edge = TRUE, kernel = "epanechnikov"), main = "Epanechnikov")

plot(density(childcareSG_ppp.km, sigma = bw.ppl, edge = TRUE, kernel = "quartic"), main="Quartic")

plot(density(childcareSG_ppp.km, sigma = bw.ppl, edge = TRUE, kernel = "disc"), main="Disc")

```

### Using a fixed bandwidth to conduct the kernel density estimation

```{r}

kde_childcareSG_600 <- density(childcareSG_ppp.km, sigma = 0.6, edge = TRUE, kernel = "gaussian")

plot(kde_childcareSG_600)

```

### Using an adaptive bandwidth to conduct the kernel density estimation

```{r}

kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method = "kernel")

plot(kde_childcareSG_adaptive)

```

### Comparing the results of kernel density estimations using adaptive versus fixed bandwidths

```{r}

par(mfrow = c(1,2))

plot(kde_childcareSG.bw, main = "Fixed bandwidth")
plot(kde_childcareSG_adaptive, main = "Adaptive bandwidth")

```

### Converting the kernel density estimate into a grid object

```{r}

gridded_kde_childcareSG_bw <- 
  as.SpatialGridDataFrame.im(kde_childcareSG.bw)

spplot(gridded_kde_childcareSG_bw)

```

### Converting gridded output into a raster object

```{r}

kde_childcareSG_bw_raster <- raster(gridded_kde_childcareSG_bw)
kde_childcareSG_bw_raster

projection(kde_childcareSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_childcareSG_bw_raster

```

### Visualing the raster object

```{r}

tm_shape(kde_childcareSG_bw_raster) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)

```

### Comparing spatial point patterns using kernel density estimation

#### Extracting the polygons of interest

```{r}

pg = mpsz_spatial[mpsz_spatial@data$PLN_AREA_N == "PUNGGOL",]
tm = mpsz_spatial[mpsz_spatial@data$PLN_AREA_N == "TAMPINES",]
ck = mpsz_spatial[mpsz_spatial@data$PLN_AREA_N == "CHOA CHU KANG",]
jw = mpsz_spatial[mpsz_spatial@data$PLN_AREA_N == "JURONG WEST",]

par(mfrow = c(2,2))
plot(pg, main = "Ponggol")
plot(tm, main = "Tampines")
plot(ck, main = "Choa Chu Kang")
plot(jw, main = "Jurong West")

```

#### Converting the spatial polygon objects into generic "sp" objects

```{r}

pg_sp = as(pg, "SpatialPolygons")
tm_sp = as(tm, "SpatialPolygons")
ck_sp = as(ck, "SpatialPolygons")
jw_sp = as(jw, "SpatialPolygons")

```

#### Creating owin objects out of the polygons of interest

```{r}

pg_owin = as(pg_sp, "owin")
tm_owin = as(tm_sp, "owin")
ck_owin = as(ck_sp, "owin")
jw_owin = as(jw_sp, "owin")

```

#### Subset the childcare events by each area of interest

```{r}

childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]

childcare_pg_ppp.km = rescale(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale(childcare_jw_ppp, 1000, "km")

```

#### Plotting the childcare events in each area of interest

```{r}

par(mfrow = c(2,2))
plot(childcare_pg_ppp.km, main = "Punggol")
plot(childcare_tm_ppp.km, main = "Tampines")
plot(childcare_ck_ppp.km, main = "Choa Chu Kang")
plot(childcare_jw_ppp.km, main = "Jurong West")

```

### Conducting the kernel density estimation of each area of interest

#### Using automatic bandwidth (diggle algorithm)

```{r}

par(mfrow = c(2,2))

plot(density(childcare_pg_ppp.km, sigma = bw.diggle, edge = TRUE, kernel="gaussian"), main="Punggol")

plot(density(childcare_tm_ppp.km, sigma = bw.diggle, edge = TRUE, kernel = "gaussian"), main = "Tempines")

plot(density(childcare_ck_ppp.km, sigma = bw.diggle, edge = TRUE, kernel = "gaussian"), main="Choa Chu Kang")

plot(density(childcare_jw_ppp.km, sigma = bw.diggle, edge = TRUE, kernel = "gaussian"), main = "Jurong West")

```

#### Using a fixed bandwidth

```{r}

par(mfrow = c(2,2))

plot(density(childcare_ck_ppp.km, sigma = 0.25, edge = TRUE, kernel = "gaussian"), main = "Chou Chu Kang")

plot(density(childcare_jw_ppp.km, sigma = 0.25, edge = TRUE, kernel = "gaussian"), main = "Jurong West")

plot(density(childcare_pg_ppp.km, sigma = 0.25, edge = TRUE, kernel = "gaussian"), main = "Punggol")

plot(density(childcare_tm_ppp.km, sigma = 0.25, edge = TRUE,  kernel = "gaussian"), main = "Tampines")

```

### Nearest Neighbour analysis

#### Clark and Evans Test

```{r}

clarkevans.test(childcareSG_ppp, correction = "none", clipregion = "coastal_owin", alternative = c("clustered"), nsim = 99)

```

#### Clark and Evans Test: Choa Chu Kang and Tampines Planning Area

```{r}

clarkevans.test(childcare_ck_ppp, correction = "none", clipregion = NULL, alternative = c("clustered"), nsim = 99)

clarkevans.test(childcare_tm_ppp, correction = "none", clipregion = NULL, alternative = c("clustered"), nsim = 99)

```

## Conducting Second Order Spatial Point Patterns Analysis

### Analysing Spatial Point Process Using G-Function

#### Computing the G-function estimation

```{r}

G_ck = Gest(childcare_ck_ppp, correction = "border")
plot(G_ck, xlim=c(0,500))

G_tm = Gest(childcare_tm_ppp, correction = "best")
plot(G_tm)

```

#### Performing a complete spatial randomness test

```{r}

G_ck.csr <- envelope(childcare_ck_ppp, Gest, nsim = 999)
plot(G_ck.csr)

G_tm.csr <- envelope(childcare_tm_ppp, Gest, correction = "all", nsim = 999)
plot(G_tm.csr)

```

### Analysing Spatial Point Process Using F-Function

#### Computing the F-function estimation

```{r}

F_ck = Fest(childcare_ck_ppp)
plot(F_ck)

F_tm = Fest(childcare_tm_ppp, correction = "best")
plot(F_tm)

```

#### Performing the Complete Spatial Randomness Test

```{r}

F_ck.csr <- envelope(childcare_ck_ppp, Fest, nsim = 999)
plot(F_ck.csr)

F_tm.csr <- envelope(childcare_tm_ppp, Fest, correction = "all", nsim = 999)
plot(F_tm.csr)

```

### Analysing Spatial Point Process Using K-Function

#### Computing the K-function estimation

```{r}

K_ck = Kest(childcare_ck_ppp, correction = "Ripley")
plot(K_ck, . -r ~ r, ylab = "K(d)-r", xlab = "d(m)")

K_tm = Kest(childcare_tm_ppp, correction = "Ripley")
plot(K_tm, . -r ~ r, ylab = "K(d)-r", xlab = "d(m)", xlim = c(0,1000))

```

#### Performing the Complete Spatial Randomness Test

```{r}

K_ck.csr <- envelope(childcare_ck_ppp, Kest, nsim = 99, rank = 1, glocal = TRUE)
plot(K_ck.csr, . - r ~ r, xlab = "d", ylab = "K(d)-r")

K_tm.csr <- envelope(childcare_tm_ppp, Kest, nsim = 99, rank = 1, glocal = TRUE)
plot(K_tm.csr, . - r ~ r, xlab = "d", ylab = "K(d)-r", xlim = c(0,500))

```

### Analysing Spatial Point Process Using L-Function

#### Computing the L-function estimation

```{r}

L_ck = Lest(childcare_ck_ppp, correction = "Ripley")
plot(L_ck, . -r ~ r, ylab = "L(d)-r", xlab = "d(m)")

L_tm = Lest(childcare_tm_ppp, correction = "Ripley")
plot(L_tm, . -r ~ r, ylab = "L(d)-r", xlab = "d(m)", xlim = c(0,1000))

```

#### Performing the Complete Spatial Randomness Test

```{r}

L_ck.csr <- envelope(childcare_ck_ppp, Lest, nsim = 99, rank = 1, glocal = TRUE)
plot(L_ck.csr, . - r ~ r, xlab = "d", ylab = "L(d)-r")

L_tm.csr <- envelope(childcare_tm_ppp, Lest, nsim = 99, rank = 1, glocal = TRUE)
plot(L_tm.csr, . - r ~ r, xlab = "d", ylab = "L(d)-r", xlim = c(0,500))

```
