---
title: "Hands-On Exercise 4: Spatial Weights and Applications"
author: "Yung Qi Yang"

format: 
  html:
    code-fold: true
    code-summary: "Reveal Code"
    
execute: 
  eval: true
  echo: true
  warning: false
date: "`r Sys.Date()`"

toc: true
toc-location: left
---

### Importing the required libraries

```{r}

pacman::p_load(sf, spdep, tmap, tidyverse, knitr)

```

### Loading the datasets into the R Environment

```{r}

hunan <- st_read(dsn = "Data/Geospatial", layer = "Hunan")
glimpse(hunan)

hunan2012 <- read_csv("Data/Aspatial/Hunan_2012.csv")
glimpse(hunan2012)

```

Left join is performed to update the attribute table of *hunan*'s SpatialPolygonDataFrame

```{r}

hunan <- left_join(hunan,hunan2012) %>% 
  select(1:4, 7, 15)
head(hunan)

```

### Visualising the Regional Development Indicator

```{r}

basemap <- tm_shape(hunan) +
  tm_polygons() +
  tm_text("NAME_3", size = 0.5)

gdppc <- qtm(hunan, "GDPPC")

tmap_arrange(basemap, gdppc, asp = 1, ncol = 2)

```

### Computing Contiguity Spatial Weights

#### Computing (**QUEEN**) contiguity based neighbours

```{r}

wm_q <- poly2nb(hunan, queen = TRUE)

summary(wm_q)

```
To see the neighbors for the first polygon in the spatial polygon object:

```{r}

wm_q[[1]]

```

The numbers represent the polygon IDs as stored in the hunan SpatialPolygonsDataFrame class.

To retrive the county name of Polygon ID=1:

```{r}

hunan$County[1]

```

To reveal the county names of the five neighboring polygons:

```{r}

hunan$NAME_3[c(2,3,4,57,85)]

```

To retrieve the GDPPC of these five counties:

```{r}

nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1

```

To display the complete weight matrix:

```{r}

str(wm_q)

```

#### Computing (**ROOK**) contiguity based neighbours

```{r}

wm_r <- poly2nb(hunan, queen = FALSE)
summary(wm_r)

```

### Visualising Contiguity Weights

```{r}

longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])

latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])

coords <- cbind(longitude, latitude)

head(coords)

```

#### Plotting a **QUEEN** contiguity based neighbours map

```{r}

plot(hunan$geometry, border = "lightgrey")

plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")

```

#### Plotting a **ROOK** contiguity based neighbours map

```{r}

plot(hunan$geometry, border = "lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")

```

#### Plotting both **QUEEN** and **ROOK** contiguity based neighbours maps together

```{r}

par(mfrow = c(1,2))
plot(hunan$geometry, border = "lightgrey", main = "Queen Contiguity")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")

plot(hunan$geometry, border = "lightgrey", main = "Rook Contiguity")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")

```

### Computing distance based neighbours

#### Determining the cut-off distance

```{r}

k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))

summary(k1dists)

```

#### Computing the fixed distance weight matrix

```{r}

wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)
wm_d62

str(wm_d62)

```

#### Displaying the weight matrix structure

```{r}

table(hunan$County, card(wm_d62))

n_comp <- n.comp.nb(wm_d62)
n_comp$nc

table(n_comp$comp.id)

```

#### Plotting the fixed distance weight matrix

Distance weight matrix is plotted as layers upon the same plot object:

```{r}

plot(hunan$geometry, border = "lightgrey")
plot(wm_d62, coords, add = TRUE)
plot(k1, coords, add = TRUE, col = "red", length = 0.08)

```

Distance weight matrix is plotted as separate layers here:

```{r}

par(mfrow = c(1,2))

plot(hunan$geometry, border = "lightgrey", main = "1st nearest neighbours")
plot(k1, coords, add = TRUE, col = "red", length = 0.08)

plot(hunan$geometry, border = "lightgrey", main = "Distance link")
plot(wm_d62, coords, add = TRUE, pch = 19, cex = 0.6)

```

#### Computing the adaptive distance weight matrix

```{r}

knn6 <- knn2nb(knearneigh(coords, k = 6))
knn6

```
#### Displaying the weight matrix structure

```{r}

str(knn6)

```

#### Plotting the adaptive distance weight matrix

```{r}

plot(hunan$geometry, border = "lightgrey")
plot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")

```

### Deriving a spatial weight matrix based on Inversed Distance Weights

```{r}

dist <- nbdists(wm_q, coords, longlat = TRUE)
ids <- lapply(dist, function(x) 1/(x))

ids

```
#### Computing a row-standardised weights matrix

Using the style = "W" option for simplicity

```{r}

rswm_q <- nb2listw(wm_q, style = "W", zero.policy = TRUE)
rswm_q

rswm_q$weights[10]

```

Using the style = "B" option for robustness

```{r}

rswm_ids <- nb2listw(wm_q, glist = ids, style = "B", zero.policy = TRUE)
rswm_ids

rswm_ids$weights[1]

summary(unlist(rswm_ids$weights))

```

### Applying the Spatial Weight Matrix to use

#### Computing Spatial Lagged values with row-standardized weights

```{r}

GDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)
GDPPC.lag

```

