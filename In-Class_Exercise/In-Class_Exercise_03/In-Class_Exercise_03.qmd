---
title: "In-Class Exercise 3: Network Kernel Density Estimation"
author: "Yung Qi Yang"

format: 
  html:
    code-fold: true
    code-summary: "Reveal Code"
    
execute: 
  eval: true
  echo: true
  warning: false
date: "`r Sys.Date()`"

toc: true
toc-location: left
---

### Loading the required libraries

```{r}

pacman::p_load(maptools, sf, raster, spatstat, tmap, tidyverse, spNetwork, classInt, viridis)


```

### Importing the required spatial datasets

```{r}

mpsz_sf <- st_read(dsn = "Data/Geospatial/Master Plan 2014", layer = "MP14_SUBZONE_WEB_PL") %>% 
  st_transform(crs = 3414)
glimpse(mpsz_sf)

childcare_sf <- st_read(dsn = "Data/Geospatial/Childcare/ChildCareServices.geojson") %>%
  st_transform(crs = 3414)
glimpse(childcare_sf)

coastal_sf <- read_rds("Data/Geospatial/rds/coastal-outline-2014.rds") %>% 
  st_transform(crs = 3413)
plot(coastal_sf)

```

### Converting the simple features objects into ppp objects

```{r}

childcare_ppp <- as.ppp(childcare_sf)
summary(childcare_ppp)

```

### Handling duplicated data points

#### Checking for duplicates

```{r}

any(duplicated(childcare_ppp))

```

### Creating an owin object from the *simple features* coastal outline

Using an owin layer ensures that the coastal outline layer is defined as the study layer, and prevents event geopoints from occurring outside the defined boundaries.

```{r}

coastal_owin <- as.owin(coastal_sf)

```

Input has to be a simple features object

#### Investigating the owin layer

```{r}

summary(coastal_owin)
plot(coastal_owin)

```

### Extracting the specific planning areas of interest from a simple features object

Unlike sp objects, sf objects can be used in conjunction with the tidyverse libraries to conduct data wrangling upon their geospatial data tables

```{r fig.width = 16, fig.height = 10}

pg <- mpsz_sf %>% 
  filter(PLN_AREA_N == "PUNGGOL")

tm <- mpsz_sf %>% 
  filter(PLN_AREA_N == "TAMPINES")

ck <- mpsz_sf %>% 
  filter(PLN_AREA_N == "CHOA CHU KANG")

jw <- mpsz_sf %>% 
  filter(PLN_AREA_N == "JURONG WEST")

par(mfrow = c(2, 2))

plot(pg, main = "Punggol")
plot(tm, main = "Tampines")
plot(ck, main = "Choa Chu Kang")
plot(jw, main = "Jurong West")

```

### Conducting Network Constrained Kernel Density Estimation

#### Importing the necessary datasets

```{r}

network_sf <- st_read(dsn = "Data/Geospatial/Punggol", layer = "Punggol_St")
childcare_sf <- st_read(dsn = "Data/Geospatial/Punggol", layer = "Punggol_CC")

```
#### Plotting the network and geopoint features

```{r}

tmap_mode("view")

tm_shape(childcare_sf) + 
  tm_dots() +
  tm_shape(network_sf) +
  tm_lines()

tmap_mode("plot")

```

#### Preparing the lixels

```{r}

lixels <- lixelize_lines(lines = network_sf, lx_length = 750, mindist = 375)

```

#### Generating the line centrepoints

```{r}

samples <- lines_center(lixels)

```

#### Performing the Network Kernel Density Estimation

```{r}

densities <- nkde(network_sf, events = childcare_sf, w = rep(1, nrow(childcare_sf)), samples = samples, kernel_name = "quartic", bw = 300, div = "bw", method = "simple", digits = 1, tol = 1, grid_shape = c(1, 1), max_depth = 8, agg = 5, sparse = TRUE, verbose = FALSE)

```

#### Re-scaling the densities

```{r}

lixels$density <- densities
samples$density <- densities

```

#### Visualising the network-constrained kernel density plot

```{r}

tmap_mode("view")

tm_shape(lixels) +
  tm_lines(col = "density") +
  
tm_shape(childcare_sf) +
  tm_dots()

tmap_mode("plot")

```

